# PROJECT KYBER

# GOAL

Implement IND-CPA Kyber PKE encryption specified in FIPS203

# Description

The `.v` files are Verilog design files written by me, the rest are auto generated by Quartus.

# File Tree

```
ðŸ“¦project-kyber
 â”£ ðŸ“‚test
 â”ƒ â”£ ðŸ“œsmall-mont.txt
 â”ƒ â”£ ðŸ“œtest-mont.txt
 â”ƒ â”— ðŸ“œtest.txt
 â”£ ðŸ“œ.gitignore
 â”£ ðŸ“œkyber.v
 â”£ ðŸ“œmontgomery_reduce.v
 â”£ ðŸ“œbarrett_reduce.v
 â”£ ðŸ“œfqmul.v
 â”£ ðŸ“œbasemul.v
 â”£ ðŸ“œbasemul_tomont.v
 â”£ ðŸ“œpolyvec_basemul_acc_mont.v
 â”£ ðŸ“œntt.v
 â”£ ðŸ“œntt_cal.v
 â”£ ðŸ“œct_butfly.v
 â”£ ðŸ“œinvntt.v
 â”£ ðŸ“œinvntt_cal.v
 â”£ ðŸ“œinvntt_fsm.v
 â”£ ðŸ“œfqmul.v
 â”— ðŸ“œREADME.md
```

# Things

> Q: what's up with polynomials? and what is basemul and NTT?

Because the base "items" are polynomials with 256 coefficients, vectors can be think of as an array of polynomials, and matrixes can be think of as a two dimensional array of polynomials.

Since the nature of polynomial multiplication is arduous if one were to do it literally (for example: $3x^2+11x+15 \times 7x^2+9x+321 = ?$), doing a polynomial multiplication with the power of 256 would require the complexity of O(256*256), this is not optimal, so Number Theoretic Transform, NTT, was born.

NTT essentially turn polynomials into a special domain that allows us to do polynomial multiplication "point-to-point." And is it what the `basemul` function is doing in the implementation.

And Inverse NTT transform 

> Q: why are the zetas different from the official FIPS203 specs?

In short, the new zetas are scaled by $2^{16}\mod 3329 = -1044$, the constant is called "**MONT**" in the C implementation.

I referenced the latest C implementation by the [PQ-CRYSTALS](https://github.com/pq-crystals/kyber) team, and they used **Montgomery reduction** for reducing a 32-bit number, (I'm guessing that 32-bit Montgomery reduction is faster than 32-bit Barrett reduction). This reduction method effectively calculates $a\cdot2^{-16}\mod{3329}$ and returns a value between -1664~1664.

When there's a need to multiply, the result product's modulus operation is the Montgomery reduction, and it usually accompanies zetas. Such as in NTT, Inverse NTT, and polynomial multiplication.

The **polynomial multiplication**: is that

- $\text{NTT}(f)=\hat{f}=(\hat{f}_0+\hat{f}_1x,\hat{f}_2+\hat{f}_3x,\dots,\hat{f}_{254}+\hat{f}_{255}x)$
- and $\hat{f}_{i}\in \mathbb{Z}_q$ 
- we have $\hat{f}\cdot\hat{g} = \hat{h} = (\hat{f}_{2i}+\hat{f}_{2i+1}x)\cdot(\hat{h}_{2i}+\hat{h}_{2i+1}x) \mod{(x^2 - \zeta^{2\text{br}_7(i)+1})}$
  - $br_7(i)$: bit reverse the input i, $br_7(1)=64$, $br_7(2)=32$ etc
  - modulus operation in this case is replace the $x^2$ with the $\zeta^{2\text{br}_7(i)+1}$
  - $\hat{h} = (\hat{f}_{2i}\hat{h}_{2i} + \hat{f}_{2i+1}\hat{h}_{2i+1}\zeta^{2\text{br}_7(i)+1}) + (\hat{f}_{2i}\hat{h}_{2i+1}+\hat{f}_{2i+1}\hat{h}_{2i})x$

The multiplications are handled by Montgomery reduction, since there's no more prescaled constant to mitigate the $2^{-16} \mod 3329$ in the reduction itself (except for the ones multiplies the zeta, because it is prescaled), the resulting product will be off by a **MONT**.

The polynomial multiplication will always follow an Inverse NTT function, that it puts the **MONT** constant back. Satisfying the correctness of the scheme.


> Q: why is there only one zetas? the official specs listed two?

(this has something to do with the quark of montgomery reduction, how inverse ntt's zeta is arranged, and congruence. I haven't completely figure out the first one but the latter two I have)

(you can argue that montgomery reduction is resource heavy and barrett reduction is better, but I argue that a 32-bit barrett reduction can be more expensive, I have no proof)



# NTT

> **Number theoretic transform**, by turning polynomials into the NTT domain using this transform, the product of two polynomials in NTT domain can be calculated element by element, thus lowering the computation complexity.

## Design rationale

- **dual dual-port RAM**
  - FPGA has specific hardware and can only do two reads or two writes with two unique addresses
  - NTT layers require two reads and two writes at the same time
    - if there's only one RAM, the entire pipeline must be paused to accommodate the reads and writes (pausing read while writing or pausing write while reading)
    - if there's two RAM, one can focus on reading while the other focus on writing. once a layer is completed, flip the direction and read from the RAM that was written and vice versa.
- **read and write latency**
  - to account for this, there are two flags to control the behavior of read/write index change and memory write. `stall` and `wr_ctrl`
- **layer control**
  - the NTT layer register is controlled by the write index logic nest
  - as the layer switch to the next one, it resumes read index, memory read, and starts the timer for write index

## potential improvements 

- (written at 2025-08-15)
  - separation of FSM and calculation logic
    - while the indexing logic is good enough, the entire state machine is still quite "spaghetti."
    - it works in simulation and in RTL it synthesized less logic elements than I expected (750), I think much can still improve
  - read and write accountability
    - there should be a 1 bit tag array for every slot in RAM the external module write or read 
  - somethings can be hardcoded (e.g. the index for each layer) but it's a logic to memory trade-off
  - MORE NTT calculation logics
    - at the moment there's only one, but to add more, it's caught by the memory bottle-neck
- (written at 2025-09-01)
  - Ping Pong Buffer code can be refactored
    - fix the two indexes to RAMs
    - handle the indexes via FSM
  - 

# CBD

> **Centered binomial distribution**, it's the method Kyber used to generate the "errors." The range of number is -*eta* ~ +*eta*, and *eta* can be 2 or 3 depends on the security level (parameter sets) selected.

## Design rationale

- for ML-KEM-768, only the eta = 2 is implemented
- **RAM**: true dual port RAM
  - array depth of 32 (32 slots)
  - array width of 32 (23 bit number)

- stages
  1. writing two 32 bit hashes into RAM
  2. upon completion of hash writing, start sampling CBD by reading hash from RAM port 1 and writing the sampled hash to RAM port 2
     - in `cbd2_cal` the sampled number will be 4 bit wide to represent numbers in {-2,-1,0,1,2}, in hexadecimal representation will be {0xF,0xE,0x0,0x1,0x2}  
     - it stitch the sampled hash, total of 8 numbers, back into 32 bit block to save space (e.g. {-1,-2,0,2,1,0,1,-2} -> 0xFE02101F)
  3. once the sampling completes, raise `ok_out` to high. the external module can raise `readout` to high to signal the `cbd.v` module to output the stored numbers once
     - uses a timer to regulate serializing the 32 bit block that contains 8 numbers
     - since the "error" for encryption is considered secret, should be discarded, and should not be reused, I made the decision to force external module not to request the same "error" once cbd module completes full output.

## potential improvements 
- (written at 2025-08-15)
  - separation of FSM and calculations
    - the current iteration is very "spaghetti" and akin to a software design
    - ideally there should be states and the calculation logic operate based on the states, and the states changes based on the signals from calculation logic 
  - MORE calculation logics
    - the calculation is only 24 logic elements, more should be possible if the memory allows
- (written at 2025-09-05)
  - an externally controlled input index if there's a index tagging system in the future
  - an internally controlled output index for the ease of module connecting 

# InvNTT

## Design rationale

Similar to NTT but with a finite state machine + counter inside the FSM to control the timing. 

### invntt_cal
```
 [zeta or 1397 for the last layer]
        |  +-----+
        +->|     |
f1 - f2 --->|fqmul|---> r1
            +-----+
 [-1044 or 1441 for the last layer]
         |  +-----+
         +->|     |
f1 + f2 --->|fqmul|---> r2
            +-----+
```

- `fqmul`
  - Because the very last stage needs to multiply the coefficients by 1441 using montgomery reduction, without adding another layer of multiplication, modifying zeta[1] to 1397 here ($-758\cdot 2^{16-7}\mod 3329$). Using -1044 to cancel out the effect of Montgomery reduce when it's not operating on the last layer.
- 

# NAMING CONVENTION

> My own creation is confusing me again >:(

- `readin`
  - external module signaling for incoming data
- `readout`
  - external module requesting for data
  - > if the data is not read then it will not output anything other than its default output
- `readin_<port>_ok`
  - module is available to input data
- `done` or `ok_out`
  - module is available to output data held in buffer
- `in<port>_index`
  - the index to the input data array
  - > the corresponding index for the data array happens at the same clock cycle, meaning if data[123]=567, then `dout` = 567 and `out_index` = 123
   > 
   > if there are two input data ports, such as `din_1` and `din_2`, the internal logic [(usually)](at-the-time-of-writing-I'm-not-sure) limits the `in_index` to only be an even number, `din_1` points to `in_index`+0 and `din_2` points to `in_index`+1
- `out_index`
  - the index to the output data array
  - > if there are two output data, then `out_index` always points to a even number

- anything without a `_cal.v` suffix would contain a RAM as a buffer